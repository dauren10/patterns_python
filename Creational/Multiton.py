'''
в разработке программного обеспечения многоэлементный шаблон - это шаблон проектирования, который обобщает одноэлементный шаблон. В то время как синглтон позволяет создать только один экземпляр класса, многоэлементный шаблон позволяет контролируемое создание нескольких экземпляров, которыми он управляет с помощью карты.

Вместо того, чтобы иметь один экземпляр для каждого приложения (например, объект java.lang.Runtime в языке программирования Java), шаблон multiton вместо этого обеспечивает один экземпляр для каждого ключа.

Большинство людей и учебники считают это одноэлементным шаблоном. Например, многотонность явно не упоминается в авторитетном учебнике по объектно-ориентированному программированию Design Patterns (он появляется как более гибкий подход, названный реестром синглетонов).
Описание

Хотя может показаться, что мультитон — это хеш-таблица с синхронизированным доступом, есть два важных отличия. Во-первых, мультитон не позволяет клиентам добавлять сопоставления. Во-вторых, мультитон никогда не возвращает нулевую или пустую ссылку; вместо этого он создает и сохраняет многотонный экземпляр по первому запросу с соответствующим ключом. Последующие запросы с тем же ключом возвращают исходный экземпляр. Хэш-таблица — это просто деталь реализации, а не единственный возможный подход. Шаблон упрощает извлечение общих объектов в приложении.

Поскольку пул объектов создается только один раз, будучи членом, связанным с классом (а не с экземпляром), мультитон сохраняет свое плоское поведение, а не превращается в древовидную структуру.

Мультитон уникален тем, что обеспечивает централизованный доступ к единому каталогу (т. е. все ключи находятся в одном и том же пространстве имен) мультитонов, где каждый экземпляр мультитона в пуле может существовать со своим собственным состоянием. Таким образом, шаблон поддерживает индексированное хранение важных для системы объектов (например, такое, которое может быть предоставлено системой LDAP). Однако мультитон ограничен широким использованием одной системой, а не мириадами распределенных систем.
'''
class Multiton(object):
    def __init__(self):
        self.instances = {}
 
    def __call__(self, key, instance):
        self.instances[key] = instance
        return instance
 
    def get_instance(self, key):
        return self.instances[key]
 
class A(object):
    def __init__(self, *args, **kw):
        pass
 
m = Multiton()
a0 = m('a0', A())
a1 = m('a1', A())
print (m.get_instance('a0'))
print (m.get_instance('a1'))
